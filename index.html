<!DOCTYPE html>
<html lang="bn">
  <head>
    <script>
      document.addEventListener("contextmenu", (event) =>
        event.preventDefault()
      );
      document.addEventListener("keydown", (event) => {
        if (
          (event.ctrlKey &&
            ["u", "s", "i", "j"].includes(event.key.toLowerCase())) ||
          event.key === "F12"
        ) {
          event.preventDefault();
        }
      });
    </script>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Online Exam</title>
    <!-- Chart.js CDN -->

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Hind+Siliguri:wght@300;400;500;600;700&display=swap");

      body {
        font-family: "Hind Siliguri", sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }

      .container {
        font-family: "Hind Siliguri", sans-serif;
        width: 100%;
        margin: auto;
        background-color: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        min-height: 80vh;
      }

      .exam-content {
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      h1 {
        color: #1b0b54;
        text-align: center;
        margin-bottom: 10px;
      }

      #timer {
        font-size: 20px;
        color: #1b0b54;
        margin-bottom: 5px;
        font-weight: normal;
        text-align: center;
      }

      #exam-info {
        font-size: 16px;
        color: black;
        margin-bottom: 20px;
        text-align: center;
      }

      #exam {
        width: 100%;
        min-height: 100px;
      }

      .chart-container {
        width: 200px;
        height: 200px;
        margin: 10px auto;
        background-color: #f9f9f9;
        border-radius: 15px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: none;
        padding: 10px;
      }

      .chart-container.visible {
        display: block;
      }

      .question-container {
        text-align: left;
        margin-bottom: 20px;
        display: block;
      }

      .question-label {
        font-weight: bold;
        color: #1b0b54;
        margin-bottom: 10px;
      }

      .options {
        margin-top: 10px;
      }

      .option {
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        cursor: pointer;
        padding: 5px;
        border-radius: 5px;
        text-transform: uppercase;
      }

      .circle {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        border: 2px solid #1b0b54;
        margin-right: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #1b0b54;
        font-weight: bold;
        font-size: 18px;
      }

      .selected .circle {
        background-color: #1b0b54;
        color: white;
      }

      .correct-text {
        color: green !important;
      }

      .incorrect-text {
        color: #ff0800 !important;
      }

      .unattempted-text {
        color: orange !important;
      }

      #submitBtn {
        font-family: hind siliguri;
        padding: 15px 30px;
        background-color: #1b0b54;
        color: white;
        border: none;
        cursor: pointer;
        font-size: 18px;
        font-weight: bold;
        border-radius: 10px;
        margin-top: 20px;
        width: 200px;
        transition: background-color 0.3s ease;
      }

      #submitBtn:hover {
        background-color: #1b0b54;
      }

      .popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        width: 300px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        border-radius: 10px;
        text-align: center;
        display: none;
        z-index: 1000;
        transition: transform 0.5s ease, opacity 0.5s ease;
      }

      .popup.slide-out {
        transform: translate(-50%, -100%);
        opacity: 0;
      }

      .popup-header {
        background-color: #1b0b54;
        color: white;
        padding: 10px;
        font-size: 20px;
        font-weight: bold;
        border-radius: 10px 10px 0 0;
      }

      .popup-body {
        padding: 15px;
      }

      .popup-body p {
        margin: 10px 0;
      }

      .confirm-btn {
        font-family: hind siliguri;
        background-color: #34c759;
        color: white;
        padding: 8px 15px;
        border: none;
        cursor: pointer;
        font-size: 14px;
        border-radius: 5px;
        margin: 5px;
      }

      .confirm-btn:hover {
        background-color: #34c759;
      }

      .cancel-btn {
        background-color: #ff3b30;
        color: white;
        padding: 8px 15px;
        border: none;
        cursor: pointer;
        font-size: 14px;
        border-radius: 5px;
        margin: 5px;
      }

      .cancel-btn:hover {
        background-color: #e02b21;
      }

      .explanation-dropdown {
        display: none;
        margin-top: 10px;
      }

      .explanation-dropdown.visible {
        display: block;
      }

      .explanation-btn {
        background-color: #1b0b54;
        color: white;
        padding: 8px 15px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        font-family: "Hind Siliguri", sans-serif;
        width: 40%;
        text-align: left;
        position: relative;
      }

      .explanation-btn:hover {
        background-color: #1b0b54;
      }

      .explanation-btn::after {
        content: "▼";
        position: absolute;
        right: 10px;
        font-size: 12px;
      }

      .explanation-btn.active::after {
        content: "▲";
      }

      .explanation-content {
        display: none;
        padding: 15px;
        background-color: #f9f9f9;
        border: 1px solid #ccc;
        border-radius: 5px;
        font-size: 14px;
        color: #000000;
        text-align: left;
        max-height: 450px;
        overflow-y: auto;
        margin-top: 5px;
      }

      .explanation-content.visible {
        display: block;
      }

      .explanation-content p {
        margin: 0 0 10px 0;
      }

      .explanation-content ul {
        margin: 0;
        padding-left: 20px;
      }

      .explanation-content li {
        margin-bottom: 5px;
      }

      .explanation-content strong {
        color: #1b0b54;
      }

      .explanation-label {
        font-weight: bold;
        color: #1b0b54;
        margin-bottom: 10px;
        display: block;
      }

      .locked .option {
        pointer-events: none;
        cursor: default;
      }

      .locked .option.selected {
        pointer-events: none;
        cursor: default;
      }
    </style>
  </head>

  <body>
    <div class="container" id="examContainer">
      <div class="exam-content">
        <h1>ফিজিক্স ১ম অনুশীলন</h1>
        <div id="timer"></div>
        <div id="exam-info"></div>
        <div class="chart-container">
          <canvas id="scoreChart"></canvas>
        </div>
        <div id="exam">
          <!-- Questions will be generated dynamically -->
        </div>
        <button id="submitBtn">সাবমিট</button>
      </div>
    </div>

    <div class="popup" id="scorePopup">
      <div class="popup-header">তোমার স্কোর</div>
      <div class="popup-body">
        <p><strong>মোট প্রশ্ন:</strong> <span id="totalQuestions"></span></p>
        <p>
          <strong>উত্তর দিয়েছো:</strong>
          <span style="color: #000000" id="answered"></span>
        </p>
        <p>
          <strong>সঠিক উত্তর:</strong>
          <span style="color: #0ab853" id="correctAnswers"></span>
        </p>
        <p>
          <strong>ভুল উত্তর:</strong>
          <span style="color: #f81010" id="wrongAnswers"></span>
        </p>
        <p>
          <strong>অনুত্তরিত:</strong>
          <span style="color: #ffc801" id="unanswered"></span>
        </p>
        <p><strong>তোমার চূড়ান্ত স্কোর:</strong></p>
        <h2 style="color: #1b0b54"><span id="finalScore"></span></h2>
        <form id="scoreForm" action="https://formspree.io/f/xpby" method="POST">
          <input type="hidden" name="userID" id="formUserID" />
          <input type="hidden" name="finalScore" id="formFinalScore" />
          <input type="hidden" name="correctAnswers" id="formCorrectAnswers" />
          <input type="hidden" name="wrongAnswers" id="formWrongAnswers" />
          <input type="hidden" name="unanswered" id="formUnanswered" />
          <button
            type="submit"
            class="confirm-btn"
            style="background-color: #1b0b54"
          >
            <b>ওকে</b>
          </button>
        </form>
      </div>
    </div>

    <div class="popup" id="confirmPopup">
      <div class="popup-header">কনফার্ম করো</div>
      <div class="popup-body">
        <p>
          ভালো করে দেখে নাও! <br />
          পরীক্ষা শেষ করতে চাও তো?
        </p>
        <button class="confirm-btn" onclick="confirmSubmit()">
          <b>হ্যাঁ</b>
        </button>
        <button class="cancel-btn" onclick="cancelSubmit()"><b>না</b></button>
      </div>
    </div>

    <script>
      let chartInstance = null;

      document.addEventListener("DOMContentLoaded", function () {
        console.log("DOM fully loaded and parsed");
        const examContainer = document.getElementById("examContainer");
        if (!examContainer) {
          console.error("Exam container not found!");
          return;
        }
        try {
          sessionStorage.setItem("isLoggedIn", "true");
          sessionStorage.setItem("userID", "anonymous");
          console.log(
            "Session storage set: isLoggedIn = true, userID = anonymous"
          );
        } catch (e) {
          console.error("Session storage error:", e);
        }
        examContainer.style.display = "block";
        console.log("Exam container displayed");
        startTimer();
        generateQuestions();

        window.addEventListener("beforeunload", function (event) {
          if (
            examContainer.style.display === "block" &&
            sessionStorage.getItem("isLoggedIn") === "true"
          ) {
            autoSubmitScore();
          }
        });
      });

      const questions = [
        {
          id: 1,
          question: "কোনটি যান্ত্রিক ত্রুটি নয়?",
          options: {
            a: "লেভেল ত্রুটি",
            b: "সূচক ত্রুটি",
            c: "শূন্য ত্রুটি",
            d: "পিছট ত্রুটি",
          },
          correct: "B",
          explanation:
            "<p>ত্রুটি মূলত তিন প্রকারের হতে পারে: যান্ত্রিক ত্রুটি, ব্যক্তিগত ত্রুটি এবং পরিবেশগত ত্রুটি। যান্ত্রিক ত্রুটিগুলি যন্ত্রের গঠনগত সমস্যা বা ত্রুটির কারণে ঘটে।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) লেভেল ত্রুটি (Level error):</b> এটি যান্ত্রিক ত্রুটির মধ্যে পড়ে। নিক্তি বা পরিমাপ যন্ত্র অনুভূমিক না থাকলে এই ত্রুটি দেখা যায়।</li><br><li><b>(B) সূচক ত্রুটি (Indexing error):</b> এটি মূলত পরিমাপের সময় পর্যবেক্ষকের ভুল বা পর্যবেক্ষণের ত্রুটি, যা ব্যক্তিগত ত্রুটির একটি অংশ। এটি সরাসরি যন্ত্রের গঠনগত সমস্যা নয়।</li><br><li><b>(C) শূন্য ত্রুটি (Zero error):</b> এটি একটি যান্ত্রিক ত্রুটি। যখন পরিমাপ যন্ত্রের শূন্য দাগ মূল স্কেলের শূন্য দাগের সাথে না মেলে, তখন এই ত্রুটি দেখা যায়।</li><br><li><b>(D) পিছট ত্রুটি (Backlash error):</b> এটিও যান্ত্রিক ত্রুটি। স্ক্রু জাতীয় যন্ত্রে স্ক্রু বা নাট ক্ষয় হয়ে গেলে বা ঢিলা হলে এই ত্রুটি দেখা যায়, যেখানে স্ক্রু ঘোরানোর সময় একটু ফাঁকা থেকে যায়।</li></ul>",
        },
        {
          id: 2,
          question:
            "ভার্নিয়ার স্কেল দিয়ে সর্বনিম্ন কত একক পর্যন্ত মাপা যায়?",
          options: {
            a: "মিলিমিটার",
            b: "ন্যানোমিটার",
            c: "মাইক্রোমিটার",
            d: "সেন্টিমিটার",
          },
          correct: "A",
          explanation:
            "<p>ভার্নিয়ার স্কেল (Vernier Scale) সাধারণত মিলিমিটারের ভগ্নাংশ পর্যন্ত পরিমাপ করতে ব্যবহৃত হয়। একটি আদর্শ ভার্নিয়ার ক্যালিপার্স দিয়ে সাধারণত 0.1 মিলিমিটার (mm) বা 0.01 সেন্টিমিটার (cm) পর্যন্ত নির্ভুলভাবে পরিমাপ করা যায়। তাই, সর্বনিম্ন যে একক পর্যন্ত মাপা যায়, তা হলো মিলিমিটার।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) মিলিমিটার (millimeter):</b> ভার্নিয়ার স্কেল মিলিমিটারের ক্ষুদ্রতম অংশ, যেমন 0.1 mm, পর্যন্ত পরিমাপ করতে পারে।</li><br><li><b>(B) ন্যানোমিটার (nanometer):</b> এটি 10<sup>-9</sup> মিটার, যা ভার্নিয়ার স্কেল দিয়ে পরিমাপ করা সম্ভব নয়। এর জন্য আরও সূক্ষ্ম যন্ত্র, যেমন পারমাণবিক বল মাইক্রোস্কোপ প্রয়োজন।</li><br><li><b>(C) মাইক্রোমিটার (micrometer):</b> এটি 10<sup>-6</sup> মিটার, যা ভার্নিয়ার স্কেল দিয়ে পরিমাপ করা সম্ভব নয়। স্ক্রুগজ কিছু ক্ষেত্রে মাইক্রোমিটারের কিছু অংশ পরিমাপ করতে পারে।</li><br><li><b>(D) সেন্টিমিটার (centimeter):</b> ভার্নিয়ার স্কেল সেন্টিমিটারের চেয়েও ছোট একক (মিলিমিটারের ভগ্নাংশ) পরিমাপ করতে পারে।</li></ul>",
        },
        {
          id: 3,
          question: "অনিয়মিত (random) ত্রুটি কী ধরনের ত্রুটি?",
          options: {
            a: "যান্ত্রিক ত্রুটি",
            b: "ব্যক্তিগত ত্রুটি",
            c: "a ও b উভয়",
            d: "ওপরের কোনোটিই নয়",
          },
          correct: "C",
          explanation:
            "<p>অনিয়মিত (Random) ত্রুটি হলো এমন ধরনের ত্রুটি যা পরিমাপের সময় অপ্রত্যাশিত এবং অনিয়মিতভাবে ঘটে। এই ত্রুটিগুলি পরিমাপের ফলাফলের উপর এলোমেলো প্রভাব ফেলে এবং তাদের উৎস সম্পূর্ণরূপে নিয়ন্ত্রণ করা কঠিন। অনিয়মিত ত্রুটি মূলত **যান্ত্রিক ত্রুটি (যন্ত্রের সূক্ষ্ম পরিবর্তন)** এবং **ব্যক্তিগত ত্রুটি (পর্যবেক্ষকের অপ্রত্যাশিত ভুল)** উভয় থেকেই উদ্ভূত হতে পারে।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) যান্ত্রিক ত্রুটি:</b> যন্ত্রের অভ্যন্তরীণ সূক্ষ্ম অসঙ্গতি, ঘর্ষণ বা তাপমাত্রার ওঠানামার কারণে কিছু অনিয়মিত ত্রুটি ঘটতে পারে।</li><br><li><b>(B) ব্যক্তিগত ত্রুটি:</b> পর্যবেক্ষকের মনোযোগের অভাব, রিডিং নিতে ভুল করা বা সামান্য পার্থক্যের কারণে অনিয়মিত ত্রুটি হতে পারে।</li><br><li><b>(C) a ও b উভয়:</b> এটিই সঠিক। অনিয়মিত ত্রুটি যান্ত্রিক এবং ব্যক্তিগত উভয় উৎস থেকেই উদ্ভূত হতে পারে, যা নিয়ন্ত্রণ করা কঠিন এবং একই পরিমাপ বারবার নিলে ভিন্ন ভিন্ন মান পাওয়া যায়।</li><br><li><b>(D) ওপরের কোনোটিই নয়:</b> এটি ভুল।</li></ul>",
        },
        {
          id: 4,
          question: "পুনরাবৃত্তিক ত্রুটি কোনটি?",
          options: {
            a: "স্ক্রু গজের শূন্য ত্রুটি",
            b: "দৃষ্টিভ্রম ত্রুটি",
            c: "অনিয়মিত ত্রুটি",
            d: "সামগ্রিক ত্রুটি",
          },
          correct: "A",
          explanation:
            "<p>পুনরাবৃত্তিক ত্রুটি (Systematic error) হলো এমন ধরনের ত্রুটি যা পরিমাপের সময় নিয়মিতভাবে ঘটে এবং একই দিকে প্রভাব ফেলে (হয় সবসময় বেশি বা সবসময় কম)। এই ত্রুটিগুলির কারণ শনাক্ত করা যায় এবং সাধারণত সংশোধন করা সম্ভব।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) স্ক্রু গজের শূন্য ত্রুটি (Zero error of screw gauge):</b> এটি একটি পুনরাবৃত্তিক বা নিয়মিত ত্রুটি। স্ক্রুগজের প্রধান স্কেল এবং বৃত্তাকার স্কেলের শূন্য দাগ যদি না মেলে, তাহলে প্রতিটি পরিমাপেই একই পরিমাণ ত্রুটি যুক্ত হবে। এই ত্রুটি ধনাত্মক বা ঋণাত্মক উভয়ই হতে পারে এবং এটিকে সংশোধন করা সম্ভব।</li><br><li><b>(B) দৃষ্টিভ্রম ত্রুটি (Parallax error):</b> এটি একটি ব্যক্তিগত ত্রুটি, যা পর্যবেক্ষকের ভুল অবস্থানের কারণে হয়। এটি পুনরাবৃত্তিক হলেও, সাধারণত ব্যক্তিগত ত্রুটির একটি প্রকার।</li><br><li><b>(C) অনিয়মিত ত্রুটি (Random error):</b> এটি অপ্রত্যাশিত এবং এলোমেলোভাবে ঘটে, যা পুনরাবৃত্তিক নয়।</li><br><li><b>(D) সামগ্রিক ত্রুটি (Gross error):</b> এটি পরিমাপকারীর গুরুতর ভুল, যেমন ভুল রিডিং নেওয়া বা ভুল সূত্র ব্যবহার করা। এটি পুনরাবৃত্তিক নয়।</li></ul>",
        },
        {
          id: 5,
          question:
            "পরিমাপে ধনাত্মক ও ঋণাত্মক উভয় প্রকার ত্রুটি হয় কোন কারণে?",
          options: {
            a: "যন্ত্রের",
            b: "পরিবেশগত",
            c: "তত্ত্বীয়",
            d: "ব্যক্তিগত",
          },
          correct: "A",
          explanation:
            "<p>পরিমাপে ধনাত্মক ও ঋণাত্মক উভয় প্রকার ত্রুটি সাধারণত **যন্ত্রের (যন্ত্রগত ত্রুটি)** কারণে হয়, বিশেষ করে শূন্য ত্রুটি (Zero error)।</p><ul><li><b>শূন্য ত্রুটি:</b> যখন একটি পরিমাপ যন্ত্রের শূন্য দাগ প্রধান স্কেলের শূন্য দাগের সাথে না মেলে, তখন শূন্য ত্রুটি হয়। যদি যন্ত্রের শূন্য দাগ প্রধান স্কেলের শূন্য দাগের ডানদিকে থাকে, তবে সেটি ধনাত্মক শূন্য ত্রুটি (Positive zero error) এবং বামদিকে থাকলে সেটি ঋণাত্মক শূন্য ত্রুটি (Negative zero error) হয়। এই উভয় প্রকারের ত্রুটিই যন্ত্রের কারণে ঘটে এবং পরিমাপকে হয় বেশি বা কম দেখায়।</li></ul><br><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) যন্ত্রের:</b> এটিই সঠিক উত্তর। শূন্য ত্রুটি, পিছট ত্রুটি, লেভেল ত্রুটি ইত্যাদি যন্ত্রের ত্রুটিগুলির কারণে ধনাত্মক বা ঋণাত্মক উভয় ধরনের ত্রুটি হতে পারে।</li><br><li><b>(B) পরিবেশগত:</b> পরিবেশগত ত্রুটিগুলি তাপমাত্রা, চাপ, আর্দ্রতা ইত্যাদির পরিবর্তনের কারণে ঘটে। এগুলি সাধারণত নিয়মিত বা অনিয়মিত হতে পারে, তবে সরাসরি ধনাত্মক বা ঋণাত্মক উভয় প্রকারের ত্রুটির উৎস হিসেবে এককভাবে চিহ্নিত করা যায় না।</li><br><li><b>(C) তত্ত্বীয়:</b> তত্ত্বীয় ত্রুটিগুলি পরিমাপের জন্য ব্যবহৃত নীতির ভুল বা মডেলের সীমাবদ্ধতার কারণে হয়, যা সরাসরি ধনাত্মক বা ঋণাত্মক ত্রুটির জন্ম দেয় না।</li><br><li><b>(D) ব্যক্তিগত:</b> ব্যক্তিগত ত্রুটিগুলি পর্যবেক্ষকের ভুল বা সীমাবদ্ধতার কারণে হয় (যেমন লম্বন ত্রুটি), যা ধনাত্মক বা ঋণাত্মক হতে পারে, তবে যন্ত্রের ত্রুটির মতো সুনির্দিষ্টভাবে শূন্য ত্রুটি হিসেবে চিহ্নিত নয়।</li></ul>",
        },
        {
          id: 6,
          question: "পর্যবেক্ষকের কারণে পাঠে যে ত্রুটি আসে তাকে বলা হয়-",
          options: {
            a: "দৈব ত্রুটি",
            b: "শূন্য ত্রুটি",
            c: "যান্ত্রিক ত্রুটি",
            d: "লম্বন ত্রুটি",
          },
          correct: "D",
          explanation:
            "<p>পর্যবেক্ষকের কারণে পাঠে যে ত্রুটি আসে তাকে **লম্বন ত্রুটি** (Parallax error) বলা হয়। এটি ব্যক্তিগত ত্রুটির একটি অংশ। যখন কোনো স্কেল বা মিটারের পাঠ নেওয়ার সময় পর্যবেক্ষক সরাসরি লম্বভাবে না তাকিয়ে আড়াআড়িভাবে দেখে, তখন এই ত্রুটি ঘটে। এর ফলে পরিমাপের মান হয় বেশি বা কম দেখায়।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) দৈব ত্রুটি (Random error):</b> এটি অপ্রত্যাশিত এবং অনিয়মিতভাবে ঘটে, যা যন্ত্র বা পরিবেশের সূক্ষ্ম পরিবর্তনের কারণে হতে পারে।</li><br><li><b>(B) শূন্য ত্রুটি (Zero error):</b> এটি যন্ত্রের ত্রুটি, যখন যন্ত্রের শূন্য দাগ মূল স্কেলের শূন্য দাগের সাথে না মেলে।</li><br><li><b>(C) যান্ত্রিক ত্রুটি (Instrumental error):</b> এটি যন্ত্রের গঠনগত সমস্যা বা ত্রুটির কারণে ঘটে।</li><br><li><b>(D) লম্বন ত্রুটি (Parallax error):</b> এটি পর্যবেক্ষকের ভুল দেখার পদ্ধতির কারণে ঘটে, যা ব্যক্তিগত ত্রুটির একটি প্রধান উদাহরণ।</li></ul>",
        },
        {
          id: 7,
          question: "নিক্তির সাহায্যে ভর পরিমাপে কোন ত্রুটি পরিহার করা যায়?",
          options: {
            a: "পিছট ত্রুটি",
            b: "লেভেল ত্রুটি",
            c: "শূন্য ত্রুটি",
            d: "পর্যবেক্ষণ ত্রুটি",
          },
          correct: "B",
          explanation:
            "<p>নিক্তির সাহায্যে ভর পরিমাপে **লেভেল ত্রুটি** (Level error) পরিহার করা যায়। লেভেল ত্রুটি ঘটে যখন নিক্তি বা তুলাযন্ত্রটি অনুভূমিকভাবে স্থাপন করা হয় না। একটি স্পিরিট লেভেল ব্যবহার করে বা যন্ত্রটিকে সঠিকভাবে সামঞ্জস্য করে এই ত্রুটি দূর করা যায়।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) পিছট ত্রুটি (Backlash error):</b> এটি স্ক্রু জাতীয় যন্ত্রে (যেমন স্ক্রুগজ) দেখা যায়, নিক্তিতে নয়।</li><br><li><b>(B) লেভেল ত্রুটি (Level error):</b> নিক্তি বা তুলাযন্ত্র সমান্তরাল না থাকলে এই ত্রুটি হয়, যা সামঞ্জস্য করে পরিহার করা যায়।</li><br><li><b>(C) শূন্য ত্রুটি (Zero error):</b> নিক্তিতে শূন্য ত্রুটি থাকতে পারে (যখন পাল্লা খালি থাকলে কাঁটা শূন্যতে না থাকে), কিন্তু এটি 'পরিহার' করার চেয়ে 'সংশোধন' করা হয়। প্রশ্নটি 'পরিহার' করার কথা বলছে।</li><br><li><b>(D) পর্যবেক্ষণ ত্রুটি (Observational error):</b> এটি ব্যক্তিগত ত্রুটি (যেমন লম্বন ত্রুটি), যা সম্পূর্ণরূপে পরিহার করা কঠিন, তবে কমিয়ে আনা যায়।</li></ul>",
        },
        {
          id: 8,
          question: "নিচের কোন ত্রুটি শুধু স্ক্রু জাতীয় যন্ত্রে থাকে?",
          options: {
            a: "ব্যক্তিগত ত্রুটি",
            b: "নিয়মিত ত্রুটি",
            c: "পিছট ত্রুটি",
            d: "লেভেল ত্রুটি",
          },
          correct: "C",
          explanation:
            "<p>নিচের ত্রুটিগুলির মধ্যে **পিছট ত্রুটি** (Backlash error) শুধু স্ক্রু জাতীয় যন্ত্রে (যেমন স্ক্রুগজ বা স্ফেরোমিটার) থাকে। পিছট ত্রুটি ঘটে যখন স্ক্রু বা নাট ক্ষয় হয়ে যায় বা আলগা থাকে, যার ফলে স্ক্রু ঘোরানোর সময় সামান্য ফাঁকা থাকে এবং সঠিক পাঠ পাওয়া যায় না।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) ব্যক্তিগত ত্রুটি (Personal error):</b> এটি পর্যবেক্ষকের কারণে হয় এবং যেকোনো পরিমাপে ঘটতে পারে।</li><br><li><b>(B) নিয়মিত ত্রুটি (Systematic error):</b> এটি একটি সাধারণ শ্রেণির ত্রুটি যা বিভিন্ন উৎস (যন্ত্র, পরিবেশ, পদ্ধতি) থেকে আসতে পারে এবং এটি নির্দিষ্ট কোনো যন্ত্রের জন্য সীমাবদ্ধ নয়। শূন্য ত্রুটি এর একটি উদাহরণ।</li><br><li><b>(C) পিছট ত্রুটি (Backlash error):</b> এই ত্রুটি স্ক্রু এবং তার নাটের মধ্যেকার ফাঁকের কারণে হয়, যা শুধুমাত্র স্ক্রু মেকানিজম আছে এমন যন্ত্রে দেখা যায়।</li><br><li><b>(D) লেভেল ত্রুটি (Level error):</b> এটি নিক্তি বা তুলাযন্ত্রের মতো যন্ত্রে দেখা যায়, যখন সেগুলো অনুভূমিকভাবে স্থাপন করা হয় না।</li></ul>",
        },
        {
          id: 9,
          question: "একটি রাশির প্রকৃত মান ও পরিমাপ্য মানের পার্থক্যকে বলে-",
          options: {
            a: "পরম ত্রুটি",
            b: "সামগ্রিক ত্রুটি",
            c: "আপেক্ষিক ত্রুটি",
            d: "পুনরাবৃত্তিক ত্রুটি",
          },
          correct: "A",
          explanation:
            "<p>একটি রাশির প্রকৃত মান (True value) এবং পরিমাপ্য মান (Measured value) এর ধনাত্মক পার্থক্যকে **পরম ত্রুটি** (Absolute error) বলে।</p><p>অর্থাৎ, পরম ত্রুটি = |প্রকৃত মান - পরিমাপ্য মান|</p><p>এটি পরিমাপের নির্ভুলতা নির্দেশ করে। পরম ত্রুটির মান যত কম হবে, পরিমাপ তত বেশি নির্ভুল হবে।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) পরম ত্রুটি (Absolute error):</b> এটিই সঠিক। এটি পরিমাপের নির্ভুলতার একটি সরাসরি পরিমাপ।</li><br><li><b>(B) সামগ্রিক ত্রুটি (Gross error):</b> এটি পরিমাপকারীর গুরুতর ভুল, যেমন ভুল রিডিং নেওয়া বা ভুল সূত্র ব্যবহার করা।</li><br><li><b>(C) আপেক্ষিক ত্রুটি (Relative error):</b> এটি পরম ত্রুটি এবং প্রকৃত মানের অনুপাত। এটি পরিমাপের নির্ভুলতাকে শতাংশ আকারে প্রকাশ করে।</li><br><li><b>(D) পুনরাবৃত্তিক ত্রুটি (Systematic error):</b> এটি নিয়মিতভাবে ঘটে এবং একই দিকে প্রভাব ফেলে (যেমন শূন্য ত্রুটি), কিন্তু এটি প্রকৃত মান ও পরিমাপ্য মানের পার্থক্য বোঝায় না, বরং ত্রুটির ধরন বোঝায়।</li></ul>",
        },
        {
          id: 10,
          question: "আপেক্ষিক ত্রুটি ও শতকরা ত্রুটির মধ্যে সম্পর্ক-",
          options: {
            a: "শতকরা ত্রুটি = আপেক্ষিক ত্রুটি × 100",
            b: "শতকরা ত্রুটি = আপেক্ষিক ত্রুটি × 100%",
            c: "আপেক্ষিক ত্রুটি = শতকরা ত্রুটি × 100",
            d: "আপেক্ষিক ত্রুটি = শতকরা ত্রুটি × 100%",
          },
          correct: "B",
          explanation:
            "<p>আপেক্ষিক ত্রুটি (Relative error) হলো পরম ত্রুটি (Absolute error) এবং প্রকৃত মানের অনুপাত।</p><p>অর্থাৎ, আপেক্ষিক ত্রুটি = (পরম ত্রুটি) / (প্রকৃত মান)</p><p>শতকরা ত্রুটি (Percentage error) হলো আপেক্ষিক ত্রুটিকে ১০০ দ্বারা গুণ করে শতাংশে প্রকাশ করা।</p><br><ul><li>সুতরাং, **শতকরা ত্রুটি = আপেক্ষিক ত্রুটি × 100%**</li></ul><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) শতকরা ত্রুটি = আপেক্ষিক ত্রুটি × 100:</b> এটি গাণিতিকভাবে সঠিক হলেও, পরিমাপের ক্ষেত্রে সাধারণত শতাংশ চিহ্ন (%) ব্যবহার করা হয়।</li><br><li><b>(B) শতকরা ত্রুটি = আপেক্ষিক ত্রুটি × 100%:</b> এটিই সঠিক প্রকাশভঙ্গি, যেখানে ফলাফল শতাংশে প্রকাশ করা হয়।</li><br><li><b>(C) আপেক্ষিক ত্রুটি = শতকরা ত্রুটি × 100:</b> এটি ভুল, কারণ এটি সম্পর্ককে উল্টে দিচ্ছে।</li><br><li><b>(D) আপেক্ষিক ত্রুটি = শতকরা ত্রুটি × 100%:</b> এটিও ভুল।</li></ul>",
        },
        {
          id: 11,
          question:
            "একটি ক্রুগজের লঘিষ্ঠ ধ্রুবকের মান 0.01mm হলে এর দ্বারা ক্ষুদ্রতম কত বেধ মাপা যায়?",
          options: {
            a: "0.1mm",
            b: "0.01mm",
            c: "1 mm",
            d: "0.05 mm",
          },
          correct: "B",
          explanation:
            "<p>একটি যন্ত্রের লঘিষ্ঠ ধ্রুবক (Least Count) বা লঘিষ্ঠ গণন (Least Count) হলো সেই যন্ত্র দ্বারা নির্ভুলভাবে পরিমাপ করা যায় এমন ক্ষুদ্রতম দৈর্ঘ্য।</p><p>যদি একটি স্ক্রুগজের লঘিষ্ঠ ধ্রুবকের মান 0.01mm হয়, তাহলে এর দ্বারা ক্ষুদ্রতম যে বেধটি নির্ভুলভাবে মাপা যাবে, সেটি হলো এর লঘিষ্ঠ ধ্রুবকের সমান, অর্থাৎ **0.01mm**। এর চেয়ে ক্ষুদ্র কোনো মান এই যন্ত্র দিয়ে সঠিকভাবে পরিমাপ করা যাবে না।</p>",
        },
        {
          id: 12,
          question: "লেভেল ত্রুটি কোন যন্ত্রের পরিমাপের জন্য প্রযোজ্য?",
          options: {
            a: "স্ক্রু-গজ",
            b: "মিটার স্কেল",
            c: "উদস্থিতি নিক্তি",
            d: "স্ফেরোমিটার",
          },
          correct: "C",
          explanation:
            "<p>লেভেল ত্রুটি (Level error) ঘটে যখন কোনো যন্ত্র অনুভূমিকভাবে (level) সঠিকভাবে স্থাপন করা হয় না। এই ত্রুটি বিশেষ করে সেইসব যন্ত্রে দেখা যায় যেখানে ভারসাম্য বা অনুভূমিক অবস্থান নির্ভুল পরিমাপের জন্য অপরিহার্য।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) স্ক্রু-গজ (Screw Gauge):</b> এটি দিয়ে সাধারণত লেভেল ত্রুটি হয় না, কারণ এটি অনুভূমিকতার উপর নির্ভরশীল নয়।</li><br><li><b>(B) মিটার স্কেল (Meter Scale):</b> এটি ব্যবহারেও সাধারণত লেভেল ত্রুটি হয় না।</li><br><li><b>(C) উদস্থিতি নিক্তি (Hydrostatic Balance):</b> এটি হলো নিক্তি বা তুলাযন্ত্রের একটি বিশেষ রূপ যা তরলের ঘনত্ব বা প্লবতা পরিমাপের জন্য ব্যবহৃত হয়। এই ধরনের যন্ত্রে সঠিকভাবে অনুভূমিক অবস্থান বজায় রাখা অত্যন্ত জরুরি, অন্যথায় লেভেল ত্রুটি দেখা দেবে এবং পরিমাপ ভুল হবে। তাই, লেভেল ত্রুটি উদস্থিতি নিক্তির পরিমাপের জন্য প্রযোজ্য।</li><br><li><b>(D) স্ফেরোমিটার (Spherometer):</b> এটি বক্রতলের ব্যাসার্ধ পরিমাপের জন্য ব্যবহৃত হয়, এবং এতেও সাধারণত লেভেল ত্রুটি হয় না।</li></ul>",
        },
        {
          id: 13,
          question: "কোন ধরনের ত্রুটি কোনোভাবেই দূর করা যায় না?",
          options: {
            a: "পদ্ধতিগত",
            b: "যান্ত্রিক",
            c: "ব্যক্তিগত",
            d: "অনিয়মিত",
          },
          correct: "D",
          explanation:
            "<p>ত্রুটির প্রকারভেদ অনুযায়ী, **অনিয়মিত (Random) ত্রুটি** কোনোভাবেই সম্পূর্ণরূপে দূর করা যায় না। যদিও অন্যান্য ত্রুটি (পদ্ধতিগত, যান্ত্রিক, ব্যক্তিগত) বিভিন্ন কৌশল বা সংশোধন পদ্ধতির মাধ্যমে কমিয়ে আনা বা দূর করা সম্ভব, অনিয়মিত ত্রুটিগুলি অপ্রত্যাশিত এবং তাদের উৎস এত সূক্ষ্ম যে তাদের সম্পূর্ণরূপে নির্মূল করা প্রায় অসম্ভব। এই ত্রুটিগুলি পরিমাপের ফলাফলে এলোমেলো ওঠানামা তৈরি করে।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) পদ্ধতিগত (Systematic):</b> পদ্ধতিগত ত্রুটিগুলি সাধারণত সনাক্ত করা যায় এবং নির্দিষ্ট পদ্ধতি প্রয়োগ করে (যেমন ক্রমাঙ্কন, সূত্র সংশোধন) দূর করা যায়।</li><br><li><b>(B) যান্ত্রিক (Instrumental):</b> যান্ত্রিক ত্রুটি (যেমন শূন্য ত্রুটি, পিছট ত্রুটি) যন্ত্রের ত্রুটির কারণে হয় এবং যন্ত্র মেরামত বা ক্রমাঙ্কনের মাধ্যমে দূর করা যায়।</li><br><li><b>(C) ব্যক্তিগত (Personal):</b> ব্যক্তিগত ত্রুটিগুলি (যেমন লম্বন ত্রুটি) পর্যবেক্ষকের মনোযোগ এবং সঠিক পদ্ধতির মাধ্যমে কমিয়ে আনা যায়।</li><br><li><b>(D) অনিয়মিত (Random):</b> এই ত্রুটিগুলি পরিমাপ প্রক্রিয়ার অন্তর্নিহিত unpredictability এর কারণে ঘটে এবং পুনরাবৃত্তিমূলক পরিমাপের গড় নিয়ে এদের প্রভাব কমানো গেলেও সম্পূর্ণরূপে দূর করা যায় না।</li></ul>",
        },
        {
          id: 14,
          question:
            "স্ফেরোমিটারের লঘিষ্ঠ ধ্রুবকের মান 0.02 mm হলে নিচের কোন বেধটি নির্ভুলভাবে মাপা যাবে?",
          options: {
            a: "0.005 mm",
            b: "0.001 mm",
            c: "0.01mm",
            d: "0.03 mm",
          },
          correct: "D",
          explanation:
            "<p>একটি যন্ত্রের লঘিষ্ঠ ধ্রুবক (Least Count) হলো সেই যন্ত্র দ্বারা নির্ভুলভাবে পরিমাপ করা যায় এমন ক্ষুদ্রতম মান। এর অর্থ হলো, যন্ত্রটি শুধুমাত্র তার লঘিষ্ঠ ধ্রুবকের পূর্ণ গুণিতক (multiple) বা তার নির্দিষ্ট ক্ষুদ্রতম একক পর্যন্ত পরিমাপ করতে পারে।</p><p>যদি স্ফেরোমিটারের লঘিষ্ঠ ধ্রুবকের মান 0.02 mm হয়, তাহলে এর দ্বারা পরিমাপ করা মান অবশ্যই 0.02 mm এর পূর্ণ গুণিতক হতে হবে।</p><br><ul><li>(A) 0.005 mm: এটি 0.02 mm এর গুণিতক নয়।</li><li>(B) 0.001 mm: এটি 0.02 mm এর গুণিতক নয়।</li><li>(C) 0.01 mm: এটি 0.02 mm এর গুণিতক নয়।</li><li>(D) 0.03 mm: এই অপশনটিও 0.02 mm এর গুণিতক নয়, তবে যদি কোনো প্রশ্ন থাকে যেখানে লঘিষ্ঠ গণন 0.02mm হয় তাহলে এটি একটি বিভ্রান্তিকর প্রশ্ন। এখানে, সবচেয়ে কাছাকাছি এবং লঘিষ্ঠ গণনের সাথে সামঞ্জস্যপূর্ণ উত্তরটি হলো লঘিষ্ঠ গণনের চেয়ে বড় যে কোনো মানকে এর গুণিতক হিসাবে পাওয়া যাবে। সঠিক উত্তরটি আসলে লঘিষ্ঠ গণনের গুণিতক হওয়া উচিত।</li></ul><br><p>তবে, যদি প্রশ্নটি এমন হয় যে, এই লঘিষ্ঠ ধ্রুবক দিয়ে কোন মানটিকে 'নির্ভুলভাবে' প্রকাশ করা যাবে, সেক্ষেত্রে উত্তর হওয়া উচিত লঘিষ্ঠ ধ্রুবকের পূর্ণ গুণিতক। প্রদত্ত অপশনগুলির মধ্যে 0.03 mm 0.02 mm এর পূর্ণ গুণিতক না হওয়ায়, এই প্রশ্নটিতে একটি ভুল আছে। এই যন্ত্র দিয়ে সাধারণত 0.02mm, 0.04mm, 0.06mm ইত্যাদি মাপা সম্ভব। তবে, যদি বিকল্পগুলির মধ্যে একমাত্র সম্ভবপর নির্ভুলতার নিকটতম মান বিবেচনা করা হয়, তবে এটি একটি সমস্যার জন্ম দেয়।</p><p>যদি এই প্রশ্নের উত্তর (D) 0.03 mm হিসাবে দেওয়া হয়, তবে ব্যাখ্যাটি জটিল হয়ে যায়, কারণ 0.03mm, 0.02mm এর গুণিতক নয়। এইরকম ক্ষেত্রে, ধরে নিতে হবে যে প্রশ্নে ভুল আছে বা উত্তরটি অন্য কোনো কারণে সঠিক হতে পারে যা সাধারণ পদার্থবিজ্ঞানের নিয়ম মেনে চলে না। কিন্তু একটি লঘিষ্ঠ ধ্রুবক দিয়ে শুধুমাত্র তার গুণিতক মাপা সম্ভব।</p><p>যদি 0.02 mm লঘিষ্ঠ গণন হয়, তাহলে কেবলমাত্র 0.02 mm এর পূর্ণ গুণিতক পরিমাপ করা সম্ভব। সুতরাং 0.03mm সঠিক উত্তর নয়। এই প্রশ্নের উত্তরটি ভুল দেওয়া হয়েছে।</p>",
        },
        {
          id: 15,
          question: "নিক্তি অনুভূমিক না থাকলে যে ত্রুটি হয় তাকে বলে-",
          options: {
            a: "শূন্য ত্রুটি",
            b: "লম্বন ত্রুটি",
            c: "লেভেল ত্রুটি",
            d: "পিছট ত্রুটি",
          },
          correct: "C",
          explanation:
            "<p>নিক্তি বা তুলাযন্ত্র অনুভূমিক (level) না থাকলে যে ত্রুটি হয় তাকে **লেভেল ত্রুটি** (Level error) বলে। এই ত্রুটি যন্ত্রের অবস্থানের কারণে ঘটে এবং এটি একটি যান্ত্রিক ত্রুটি বা নিয়মিত ত্রুটি হিসেবে বিবেচিত হয়। একটি স্পিরিট লেভেল ব্যবহার করে বা যন্ত্রটিকে সঠিকভাবে সামঞ্জস্য করে এই ত্রুটি দূর করা যায়।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) শূন্য ত্রুটি (Zero error):</b> যন্ত্রের শূন্য দাগ প্রধান স্কেলের শূন্য দাগের সাথে না মিললে এই ত্রুটি হয়।</li><br><li><b>(B) লম্বন ত্রুটি (Parallax error):</b> পর্যবেক্ষকের ভুল দেখার পদ্ধতির কারণে এই ত্রুটি হয়।</li><br><li><b>(C) লেভেল ত্রুটি (Level error):</b> এটিই সঠিক। যখন যন্ত্রের ভিত্তি সমান্তরাল বা অনুভূমিক না থাকে, তখন এই ত্রুটি দেখা যায়।</li><br><li><b>(D) পিছট ত্রুটি (Backlash error):</b> এটি স্ক্রু জাতীয় যন্ত্রে স্ক্রু বা নাটের ক্ষয়জনিত কারণে হয়।</li></ul>",
        },
        {
          id: 16,
          question: "পর্যবেক্ষণজনিত ত্রুটি কোনটি?",
          options: {
            a: "পিছট ত্রুটি",
            b: "লেভেল ত্রুটি",
            c: "এলোমেলো ত্রুটি",
            d: "লম্বন ত্রুটি",
          },
          correct: "D",
          explanation:
            "<p>পর্যবেক্ষণজনিত ত্রুটি (Observational error) হলো সেই ধরনের ত্রুটি যা পরিমাপকারীর পর্যবেক্ষণের ভুল বা ত্রুটির কারণে ঘটে। এই ধরনের ত্রুটি ব্যক্তিগত ত্রুটির আওতায় পড়ে।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) পিছট ত্রুটি (Backlash error):</b> এটি যান্ত্রিক ত্রুটি, স্ক্রু জাতীয় যন্ত্রে ঘটে।</li><br><li><b>(B) লেভেল ত্রুটি (Level error):</b> এটি যান্ত্রিক ত্রুটি, যন্ত্রের অনুভূমিকতার অভাবের কারণে ঘটে।</li><br><li><b>(C) এলোমেলো ত্রুটি (Random error):</b> এটি অনিয়মিত এবং অপ্রত্যাশিত ত্রুটি, যা নিয়ন্ত্রণ করা কঠিন।</li><br><li><b>(D) লম্বন ত্রুটি (Parallax error):</b> এটিই সঠিক। এটি পর্যবেক্ষণের সময় চোখের ভুল অবস্থানের কারণে ঘটে, যখন স্কেলের পাঠ লম্বভাবে না দেখে আড়াআড়িভাবে দেখা হয়। এটি একটি ক্লাসিক পর্যবেক্ষণজনিত ত্রুটি।</li></ul>",
        },
        {
          id: 17,
          question:
            "স্ক্রু ক্ষয় হওয়ার ফলে যন্ত্রে যে ত্রুটির উদ্ভব হয় তাকে কী বলে?",
          options: {
            a: "লম্বন ত্রুটি",
            b: "সূচক ত্রুটি",
            c: "পিছট ত্রুটি",
            d: "লেভেল ত্রুটি",
          },
          correct: "C",
          explanation:
            "<p>স্ক্রু ক্ষয় হওয়ার ফলে বা স্ক্রু এবং নাটের মধ্যেকার ফাঁকের কারণে যন্ত্রে যে ত্রুটির উদ্ভব হয় তাকে **পিছট ত্রুটি** (Backlash error) বলে। এই ত্রুটি স্ক্রু জাতীয় যন্ত্রে, যেমন স্ক্রুগজ বা স্ফেরোমিটার, দেখা যায়। যখন স্ক্রু ঘোরানো হয়, তখন ক্ষয় বা আলগা হওয়ার কারণে কিছুটা ফাঁকা থাকে, যার ফলে সঠিক পাঠ নেওয়া কঠিন হয়। এটি একটি যান্ত্রিক ত্রুটি এবং নিয়মিত ত্রুটির আওতায় পড়ে।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) লম্বন ত্রুটি (Parallax error):</b> এটি পর্যবেক্ষকের ভুল দেখার পদ্ধতির কারণে হয়।</li><br><li><b>(B) সূচক ত্রুটি (Indexing error):</b> এটি একটি ব্যক্তিগত ত্রুটি, যা পর্যবেক্ষণের ভুল বা পরিমাপের সময় ভুল গণনার কারণে ঘটে।</li><br><li><b>(C) পিছট ত্রুটি (Backlash error):</b> এটিই সঠিক। স্ক্রু-জাতীয় যন্ত্রের স্ক্রু বা নাট ক্ষয়ের কারণে এই ত্রুটি ঘটে।</li><br><li><b>(D) লেভেল ত্রুটি (Level error):</b> যন্ত্রের অনুভূমিক অবস্থানের অভাবের কারণে এই ত্রুটি হয়।</li></ul>",
        },
        {
          id: 18,
          question: "একটি সূক্ষ্ম তারের ব্যাস কোন যন্ত্রটি দিয়ে পরিমাপ করবে?",
          options: {
            a: "স্লাইড ক্যালিপার্স",
            b: "স্ক্রুগজ",
            c: "স্ফেরোমিটার",
            d: "সব কয়টি দ্বারা",
          },
          correct: "B",
          explanation:
            "<p>একটি সূক্ষ্ম তারের ব্যাস পরিমাপের জন্য সবচেয়ে নির্ভুল যন্ত্র হলো **স্ক্রুগজ** (Screw Gauge)। স্ক্রুগজ মিলিমিটারের ১০০ ভাগের এক ভাগ বা 0.01 mm পর্যন্ত পরিমাপ করতে পারে, যা স্লাইড ক্যালিপার্সের চেয়েও বেশি সূক্ষ্ম। তারের মতো ছোট বস্তুর ব্যাস নির্ভুলভাবে পরিমাপ করার জন্য এই ধরনের উচ্চ নির্ভুলতা প্রয়োজন।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) স্লাইড ক্যালিপার্স (Slide Calipers):</b> এটি সাধারণত মিলিমিটারের এক দশমাংশ (0.1 mm) পর্যন্ত পরিমাপ করতে পারে। এটি তুলনামূলকভাবে মোটা তারের ব্যাস বা ছোট বস্তুর দৈর্ঘ্য পরিমাপের জন্য উপযুক্ত, কিন্তু সূক্ষ্ম তারের জন্য স্ক্রুগজের চেয়ে কম নির্ভুল।</li><br><li><b>(B) স্ক্রুগজ (Screw Gauge):</b> এটি উচ্চ নির্ভুলতার জন্য ব্যবহৃত হয় এবং 0.01 mm পর্যন্ত ক্ষুদ্রতম পরিমাপ করতে সক্ষম। এটি সূক্ষ্ম তারের ব্যাস, কাগজের পুরুত্ব ইত্যাদি পরিমাপের জন্য আদর্শ।</li><br><li><b>(C) স্ফেরোমিটার (Spherometer):</b> এটি সাধারণত বক্রতলের ব্যাসার্ধ পরিমাপের জন্য ব্যবহৃত হয়, তারের ব্যাস পরিমাপের জন্য নয়।</li><br><li><b>(D) সব কয়টি দ্বারা:</b> যদিও স্লাইড ক্যালিপার্স দিয়ে তারের ব্যাস মাপা যায়, স্ক্রুগজই সবচেয়ে নির্ভুল ফলাফল দেবে, তাই 'সব কয়টি দ্বারা' সঠিক নয় যদি 'সবচেয়ে নির্ভুল' উদ্দেশ্য হয়।</li></ul>",
        },
        {
          id: 19,
          question: "স্লাইড ক্যালিপার্স দ্বারা ন্যূনতম কত দূরত্ব মাপা যায়?",
          options: {
            a: "1 mm",
            b: "0.01mm",
            c: "0.1 mm",
            d: "ভার্নিয়ার ধ্রুবক",
          },
          correct: "D",
          explanation:
            "<p>স্লাইড ক্যালিপার্স (Slide Calipers) দ্বারা ন্যূনতম যে দূরত্বটি নির্ভুলভাবে মাপা যায়, সেটি হলো এর **ভার্নিয়ার ধ্রুবক** (Vernier Constant) বা লঘিষ্ঠ গণন (Least Count)। ভার্নিয়ার ধ্রুবক হলো প্রধান স্কেলের ক্ষুদ্রতম এক ঘর এবং ভার্নিয়ার স্কেলের এক ঘরের দৈর্ঘ্যের পার্থক্য। এটিই যন্ত্রের পরিমাপের ক্ষুদ্রতম সীমা নির্দেশ করে। সাধারণত, স্লাইড ক্যালিপার্সের ভার্নিয়ার ধ্রুবক 0.1 mm বা 0.01 cm হয়।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) 1 mm:</b> এটি প্রধান স্কেলের ক্ষুদ্রতম ঘরের মান হতে পারে, কিন্তু ভার্নিয়ার স্কেল আরও সূক্ষ্মভাবে পরিমাপ করতে পারে।</li><br><li><b>(B) 0.01mm:</b> এটি সাধারণত স্ক্রুগজের লঘিষ্ঠ গণন।</li><br><li><b>(C) 0.1 mm:</b> এটি অনেক স্লাইড ক্যালিপার্সের লঘিষ্ঠ গণন বা ভার্নিয়ার ধ্রুবকের একটি সাধারণ মান, কিন্তু এটি সরাসরি 'ভার্নিয়ার ধ্রুবক' নয়, বরং ভার্নিয়ার ধ্রুবকের একটি নির্দিষ্ট মান।</li><br><li><b>(D) ভার্নিয়ার ধ্রুবক:</b> এটিই সবচেয়ে সঠিক উত্তর, কারণ প্রতিটি স্লাইড ক্যালিপার্সের ভার্নিয়ার ধ্রুবকই হলো তার দ্বারা পরিমাপ করা যায় এমন ক্ষুদ্রতম দূরত্ব।</li></ul>",
        },
        {
          id: 20,
          question:
            "পাতলা পাতের পুরুত্ব এবং বক্রতলের ব্যাসার্ধ পরিমাপের যন্ত্রের নাম কী?",
          options: {
            a: "স্ফেরোমিটার",
            b: "স্লাইড ক্যালিপার্স",
            c: "স্ক্রুগজ",
            d: "ভার্নিয়ার স্কেল",
          },
          correct: "A",
          explanation:
            "<p>পাতলা পাতের পুরুত্ব এবং বক্রতলের ব্যাসার্ধ পরিমাপের জন্য ব্যবহৃত যন্ত্রের নাম হলো **স্ফেরোমিটার** (Spherometer)। এটি একটি উচ্চ নির্ভুলতার পরিমাপ যন্ত্র যা মূলত গোলীয় তলের বক্রতার ব্যাসার্ধ (Radius of Curvature) এবং ছোট আকারের পাতের পুরুত্ব পরিমাপের জন্য ডিজাইন করা হয়েছে।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) স্ফেরোমিটার:</b> এটি বক্রতলের ব্যাসার্ধ এবং পাতলা পাতের পুরুত্ব পরিমাপের জন্য উপযুক্ত যন্ত্র।</li><br><li><b>(B) স্লাইড ক্যালিপার্স:</b> এটি সাধারণত দৈর্ঘ্য, প্রস্থ, উচ্চতা, সিলিন্ডারের ব্যাস এবং গভীরতা পরিমাপের জন্য ব্যবহৃত হয়, তবে বক্রতলের ব্যাসার্ধ পরিমাপের জন্য এটি আদর্শ নয়।</li><br><li><b>(C) স্ক্রুগজ:</b> এটি খুব সূক্ষ্ম বস্তুর ব্যাস (যেমন তারের ব্যাস) বা ছোট পাতের পুরুত্ব পরিমাপের জন্য ব্যবহৃত হয়, কিন্তু বক্রতলের ব্যাসার্ধ পরিমাপের জন্য নয়।</li><br><li><b>(D) ভার্নিয়ার স্কেল:</b> এটি একটি সহায়ক স্কেল যা স্লাইড ক্যালিপার্স এবং অন্যান্য যন্ত্রে ব্যবহৃত হয় সূক্ষ্ম পরিমাপের জন্য, তবে এটি এককভাবে পরিমাপ যন্ত্র নয়।</li></ul>",
        },
        {
          id: 21,
          question: "স্ক্রুগজ দ্বারা ন্যূনতম কত দূরত্ব মাপা যাবে?",
          options: {
            a: "1mm",
            b: "0.01mm",
            c: "0.1mm",
            d: "যন্ত্রের লঘিষ্ঠ গণন",
          },
          correct: "D",
          explanation:
            "<p>স্ক্রুগজ (Screw Gauge) দ্বারা ন্যূনতম যে দূরত্বটি নির্ভুলভাবে মাপা যাবে, সেটি হলো **যন্ত্রের লঘিষ্ঠ গণন** (Least Count)। লঘিষ্ঠ গণন হলো একটি যন্ত্রের ক্ষুদ্রতম পরিমাপ ক্ষমতা। স্ক্রুগজের ক্ষেত্রে, এটি সাধারণত 0.01 mm হয়ে থাকে, কিন্তু এটি যন্ত্রভেদে ভিন্ন হতে পারে। তাই, সবচেয়ে সঠিক উত্তর হলো যন্ত্রের নির্দিষ্ট লঘিষ্ঠ গণন।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) 1mm:</b> এটি অনেক ক্ষেত্রে প্রধান স্কেলের ক্ষুদ্রতম একক হতে পারে, কিন্তু স্ক্রুগজ আরও সূক্ষ্মভাবে পরিমাপ করতে পারে।</li><br><li><b>(B) 0.01mm:</b> এটি অনেক স্ক্রুগজের একটি সাধারণ লঘিষ্ঠ গণন, কিন্তু এটি সকল স্ক্রুগজের জন্য প্রযোজ্য নাও হতে পারে।</li><br><li><b>(C) 0.1mm:</b> এটি সাধারণত স্লাইড ক্যালিপার্সের লঘিষ্ঠ গণন।</li><br><li><b>(D) যন্ত্রের লঘিষ্ঠ গণন:</b> এটিই সবচেয়ে সঠিক উত্তর, কারণ প্রতিটি যন্ত্রের নিজস্ব লঘিষ্ঠ গণন থাকে, যা তার দ্বারা পরিমাপ করা যায় এমন ক্ষুদ্রতম দূরত্ব নির্দেশ করে।</li></ul>",
        },
        {
          id: 22,
          question:
            "একটি ভার্নিয়ার স্কেলের প্রধান স্কেলে ক্ষুদ্রতম এক ঘর এবং ভার্নিয়ার স্কেলের এক ঘরের দৈর্ঘ্যের পার্থক্যকে কী বলে?",
          options: {
            a: "লঘিষ্ঠ গণন",
            b: "পিচ",
            c: "ভার্নিয়ার ধ্রুবক",
            d: "খণ্ডাংশ",
          },
          correct: "C",
          explanation:
            "<p>একটি ভার্নিয়ার স্কেলের (Vernier Scale) প্রধান স্কেলের ক্ষুদ্রতম এক ঘরের মান (S) এবং ভার্নিয়ার স্কেলের এক ঘরের মান (V) এর পার্থক্যকে **ভার্নিয়ার ধ্রুবক** (Vernier Constant) বলা হয়।</p><p>ভার্নিয়ার ধ্রুবক = S - V</p><p>এটিই ভার্নিয়ার যন্ত্রের লঘিষ্ঠ গণন (Least Count) এবং এর মাধ্যমে যন্ত্রটি দ্বারা মাপা যায় এমন ক্ষুদ্রতম দৈর্ঘ্য নির্দেশিত হয়।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) লঘিষ্ঠ গণন (Least Count):</b> ভার্নিয়ার ধ্রুবকই হলো ভার্নিয়ার যন্ত্রের লঘিষ্ঠ গণন।</li><br><li><b>(B) পিচ (Pitch):</b> এটি স্ক্রু জাতীয় যন্ত্রে (যেমন স্ক্রুগজ) ব্যবহৃত হয়, যেখানে বৃত্তাকার স্কেলকে একবার ঘোরালে রৈখিক স্কেল বরাবর যে দূরত্ব অতিক্রম করে তাকে পিচ বলে।</li><br><li><b>(C) ভার্নিয়ার ধ্রুবক (Vernier Constant):</b> এটিই সঠিক। এটি ভার্নিয়ার স্কেলের মূল সংজ্ঞা।</li><br><li><b>(D) খণ্ডাংশ (Fraction):</b> এটি একটি সাধারণ শব্দ, যা কোনো নির্দিষ্ট পরিমাপের পরিভাষা নয়।</li></ul>",
        },
        {
          id: 23,
          question:
            "একটি ক্রুগজের বৃত্তাকার স্কেলকে সম্পূর্ণ একবার ঘুরালে রৈখিক স্কেল বরাবর যে দূরত্ব অতিক্রম করে তাকে কী বলে?",
          options: {
            a: "পিচ",
            b: "ভার্নিয়ার ধ্রুবক",
            c: "লঘিষ্ঠ গণন",
            d: "খণ্ডাংশ",
          },
          correct: "A",
          explanation:
            "<p>একটি স্ক্রুগজের (Screw Gauge) বৃত্তাকার স্কেলকে সম্পূর্ণ একবার ঘুরালে রৈখিক স্কেল বরাবর যে দূরত্ব অতিক্রম করে তাকে **পিচ** (Pitch) বলা হয়। পিচ হলো স্ক্রুর একটি ঘূর্ণনে তার অক্ষ বরাবর অতিক্রান্ত রৈখিক দূরত্ব। এটি স্ক্রুগজের একটি গুরুত্বপূর্ণ বৈশিষ্ট্য যা এর লঘিষ্ঠ গণন নির্ণয়ে ব্যবহৃত হয়।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) পিচ (Pitch):</b> এটিই সঠিক। এটি স্ক্রুগজের গঠনগত একটি পরিমাপ।</li><br><li><b>(B) ভার্নিয়ার ধ্রুবক (Vernier Constant):</b> এটি ভার্নিয়ার ক্যালিপার্সের সাথে সম্পর্কিত।</li><br><li><b>(C) লঘিষ্ঠ গণন (Least Count):</b> এটি পিচ এবং বৃত্তাকার স্কেলের ভাগসংখ্যা দিয়ে নির্ণয় করা হয় (লঘিষ্ঠ গণন = পিচ / বৃত্তাকার স্কেল ভাগসংখ্যা)। এটি নিজেই সরাসরি পিচ নয়।</li><br><li><b>(D) খণ্ডাংশ (Fraction):</b> এটি একটি সাধারণ শব্দ, পরিমাপের কোনো নির্দিষ্ট পরিভাষা নয়।</li></ul>",
        },
        {
          id: 24,
          question:
            "একটি স্ফেরোমিটারের বৃত্তাকার স্কেলটি সম্পূর্ণ একবার ঘুরালে এটি রৈখিক স্কেল বরাবর যে দূরত্ব অতিক্রম করে তাকে কী বলে?",
          options: {
            a: "লঘিষ্ঠ গণন",
            b: "ভার্নিয়ার ধ্রুবক",
            c: "পিচ",
            d: "খণ্ডাংশ",
          },
          correct: "C",
          explanation:
            "<p>একটি স্ফেরোমিটারের (Spherometer) বৃত্তাকার স্কেলটি সম্পূর্ণ একবার ঘুরালে এটি রৈখিক স্কেল বরাবর যে দূরত্ব অতিক্রম করে তাকে **পিচ** (Pitch) বলা হয়। স্ফেরোমিটারের কার্যপ্রণালী স্ক্রুগজের মতো একই স্ক্রু মেকানিজমের উপর নির্ভরশীল, যেখানে স্ক্রুকে ঘোরানোর মাধ্যমে রৈখিক সরণ ঘটে। তাই, স্ক্রুগজের মতো স্ফেরোমিটারেও পিচ এর একটি গুরুত্বপূর্ণ পরিমাপ।</p><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) লঘিষ্ঠ গণন (Least Count):</b> এটি পিচ এবং বৃত্তাকার স্কেলের ভাগসংখ্যা দিয়ে নির্ণয় করা হয় (লঘিষ্ঠ গণন = পিচ / বৃত্তাকার স্কেল ভাগসংখ্যা)।</li><br><li><b>(B) ভার্নিয়ার ধ্রুবক (Vernier Constant):</b> এটি ভার্নিয়ার ক্যালিপার্সের সাথে সম্পর্কিত।</li><br><li><b>(C) পিচ (Pitch):</b> এটিই সঠিক। স্ফেরোমিটার এবং স্ক্রুগজ উভয়ের ক্ষেত্রেই এটি প্রযোজ্য।</li><br><li><b>(D) খণ্ডাংশ (Fraction):</b> এটি একটি সাধারণ শব্দ, পরিমাপের কোনো নির্দিষ্ট পরিভাষা নয়।</li></ul>",
        },
        {
          id: 25,
          question: "ক্রুগজ বা স্ফেরোমিটারের লঘিষ্ঠ গণন হচ্ছে-",
          options: {
            a: "বৃত্তাকার স্কেল ভাগসংখ্যা / পিচ",
            b: "বৃত্তাকার স্কেল ভাগসংখ্যা × পিচ",
            c: "পিচ / বৃত্তাকার স্কেল ভাগসংখ্যা",
            d: "পিচ + বৃত্তাকার স্কেল ভাগসংখ্যা",
          },
          correct: "C",
          explanation:
            "<p>স্ক্রুগজ (Screw Gauge) বা স্ফেরোমিটারের (Spherometer) লঘিষ্ঠ গণন (Least Count) নির্ণয়ের সূত্রটি হলো:</p><br><p><b>লঘিষ্ঠ গণন = পিচ / বৃত্তাকার স্কেল ভাগসংখ্যা</b></p><br><ul><li><b>পিচ (Pitch):</b> বৃত্তাকার স্কেলকে একবার পূর্ণ ঘোরালে রৈখিক স্কেল বরাবর অতিক্রান্ত দূরত্ব।</li><li><b>বৃত্তাকার স্কেল ভাগসংখ্যা:</b> বৃত্তাকার স্কেলে মোট যতগুলি ভাগ থাকে।</li></ul><br><p>এই সূত্র ব্যবহার করে যন্ত্রটি দ্বারা পরিমাপ করা যায় এমন ক্ষুদ্রতম মান নির্ণয় করা হয়।</p>",
        },
        {
          id: 26,
          question: "গোলকের আয়তন নির্ণয়ের সূত্র কী?",
          options: {
            a: "⅙ πr<sup>3</sup>",
            b: "4/3πd<sup>3</sup>",
            c: "⅙ πd<sup>3</sup>",
            d: "4/3πr<sup>3</sup>",
          },
          correct: "D",
          explanation:
            "<p>গোলকের আয়তন (Volume of a Sphere) নির্ণয়ের সঠিক সূত্র হলো ব্যাসার্ধ (r) এর সাপেক্ষে **4/3πr<sup>3</sup>**।</p><br><p>যদি ব্যাস (d) এর সাপেক্ষে আয়তন নির্ণয় করতে হয়, তাহলে r = d/2 বসিয়ে পাই:</p><p>আয়তন = 4/3π(d/2)<sup>3</sup></p><p>আয়তন = 4/3π(d<sup>3</sup>/8)</p><p>আয়তন = (4/24)πd<sup>3</sup></p><p>আয়তন = **⅙ πd<sup>3</sup>**</p><br><p>প্রশ্নটিতে গোলকের আয়তন নির্ণয়ের সূত্র চাওয়া হয়েছে এবং অপশন (c) ⅙ πd<sup>3</sup> সঠিক। তবে, অপশন (D) 4/3πr<sup>3</sup> ও সঠিক। প্রশ্নটি যেহেতু 'কী' জানতে চাইছে, তাই উভয় সূত্রই গ্রহণযোগ্য। তবে, বেশিরভাগ ক্ষেত্রে ব্যাসার্ধ ব্যবহার করেই সূত্র প্রকাশ করা হয়। প্রদত্ত উত্তরে (c) থাকায়, আমরা ব্যাসের সাপেক্ষে সূত্রটি বিবেচনা করব।</p><br><p>বিভিন্ন অপশনগুলোর ব্যাখ্যা নিচে দেওয়া হলো:</p><br><ul><li><b>(A) ⅙ πr<sup>3</sup>:</b> এটি ব্যাসার্ধের সাপেক্ষে সঠিক নয়।</li><br><li><b>(B) 4/3πd<sup>3</sup>:</b> এটি ব্যাসের সাপেক্ষে সঠিক নয়।</li><br><li><b>(C) ⅙ πd<sup>3</sup>:</b> এটি ব্যাসের সাপেক্ষে গোলকের আয়তন নির্ণয়ের সঠিক সূত্র।</li><br><li><b>(D) 4/3πr<sup>3</sup>:</b> এটি ব্যাসার্ধের সাপেক্ষে গোলকের আয়তন নির্ণয়ের সঠিক সূত্র।</li></ul><br><p>যেহেতু প্রশ্নের উত্তর (c) দেওয়া আছে, তাই আমরা ধরে নিচ্ছি ব্যাসের সাপেক্ষে সূত্রটি চাওয়া হয়েছে।</p>",
        },
      ];

      const totalQuestions = questions.length;
      let timeLeft = Math.floor(totalQuestions / 2) * 60;
      const timerElement = document.getElementById("timer");
      let timerInterval;

      function updateTimer() {
        const minutes = Math.floor(timeLeft / 60);
        const seconds = timeLeft % 60;
        timerElement.innerText = `${toBengaliNumber(
          minutes
        )} মিনিট ${toBengaliNumber(seconds)} সেকেন্ড`;

        if (timeLeft > 0) {
          timeLeft--;
        } else {
          stopTimer();
          confirmSubmit();
        }
      }

      function startTimer() {
        console.log("Starting timer");
        timerElement.innerText = `${toBengaliNumber(
          Math.floor(timeLeft / 60)
        )} মিনিট ${toBengaliNumber(timeLeft % 60)} সেকেন্ড`;
        timerInterval = setInterval(updateTimer, 1000);
      }

      function stopTimer() {
        clearInterval(timerInterval);
        console.log("Timer stopped");
      }

      function toBengaliNumber(num) {
        const bengaliDigits = [
          "০",
          "১",
          "২",
          "৩",
          "৪",
          "৫",
          "৬",
          "৭",
          "৮",
          "৯",
        ];
        let numStr = num.toString();

        let isNegative = num < 0;
        if (isNegative) {
          numStr = numStr.substring(1);
        }

        if (numStr.includes(".")) {
          let [integerPart, decimalPart] = numStr.split(".");
          let integerBengali = integerPart
            .split("")
            .map((digit) => bengaliDigits[parseInt(digit)])
            .join("");
          let decimalBengali = decimalPart
            .split("")
            .map((digit) => bengaliDigits[parseInt(digit)])
            .join("");
          return (
            (isNegative ? "−" : "") + integerBengali + "." + decimalBengali
          );
        } else {
          let integerBengali = numStr
            .split("")
            .map((digit) => bengaliDigits[parseInt(digit)])
            .join("");
          return (isNegative ? "−" : "") + integerBengali;
        }
      }

      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      function generateQuestions() {
        console.log("Generating questions");
        const examContainer = document.querySelector("#exam");
        if (!examContainer) {
          console.error("Exam container (#exam) not found!");
          return;
        }
        examContainer.innerHTML = "";
        console.log("Questions array:", questions);
        const shuffledQuestions = shuffleArray([...questions]);
        shuffledQuestions.forEach((question, index) => {
          console.log(`Generating question ${index + 1}:`, question);
          const questionDiv = document.createElement("div");
          questionDiv.classList.add("question-container");
          questionDiv.setAttribute("data-question", question.id);
          questionDiv.setAttribute("data-correct", question.correct);

          let optionsHTML = "";
          for (let option in question.options) {
            optionsHTML += `
                                <label class="option" data-option="${option}">
                                  <div class="circle">${option}</div>
                                  <span class="option-text">${question.options[option]}</span>
                                </label>
                              `;
          }

          const explanationHTML = question.explanation
            ? `<div class="explanation-dropdown">
                                   <button class="explanation-btn">ব্যাখ্যা দেখো</button>
                                   <div class="explanation-content">
                                     <div class="explanation-label">ব্যাখ্যা:</div>
                                     ${question.explanation}
                                   </div>
                                 </div>`
            : "";

          questionDiv.innerHTML = `
                              <p class="question-label">${index + 1}. ${
            question.question
          }</p>
                              <div class="options">
                                ${optionsHTML}
                              </div>
                              ${explanationHTML}
                            `;
          examContainer.appendChild(questionDiv);
          console.log(`Appended question ${index + 1} to exam container`);
        });

        const questionContainers = document.querySelectorAll(
          ".question-container"
        );
        console.log(`Found ${questionContainers.length} question containers`);
        questionContainers.forEach((container, idx) => {
          console.log(`Setting question ${idx + 1} to visible`);
          container.style.display = "block";
        });

        document.querySelectorAll(".option").forEach((option) => {
          option.addEventListener(
            "click",
            function (e) {
              e.preventDefault();
              const parent = this.closest(".question-container");
              if (parent.classList.contains("locked")) return;
              parent.classList.add("locked");
              parent.querySelectorAll(".option").forEach((el) => {
                if (el !== this) {
                  el.style.pointerEvents = "none";
                  el.style.cursor = "default";
                }
                el.classList.remove("selected");
              });
              this.classList.add("selected");
              console.log(
                `Option selected for question ${parent.getAttribute(
                  "data-question"
                )}: ${this.getAttribute("data-option")}`
              );
            },
            { once: true }
          );
        });

        document.querySelectorAll(".explanation-btn").forEach((btn) => {
          btn.addEventListener("click", function () {
            const content = this.nextElementSibling;
            content.classList.toggle("visible");
            this.classList.toggle("active");
            console.log("Toggled explanation visibility");
          });
        });

        const examInfo = document.getElementById("exam-info");
        if (examInfo) {
          examInfo.innerText = `পূর্ণ নম্বরঃ ${toBengaliNumber(
            totalQuestions
          )}`;
          console.log("Exam info updated");
        } else {
          console.error("Exam info element not found!");
        }
      }

      function initializeChart() {
        console.log("Initializing chart");
        const ctx = document.getElementById("scoreChart").getContext("2d");
        chartInstance = new Chart(ctx, {
          type: "pie",
          data: {
            labels: ["ঠিক উত্তর", "ভুল উত্তর", "অনুত্তরিত"],
            datasets: [
              {
                data: [0, 0, 0],
                backgroundColor: ["#34c759", "#ff3b30", "#007aff"],
                borderColor: "#fff",
                borderWidth: 2,
                hoverOffset: 10,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            cutout: "10%",
            layout: {
              padding: 10,
            },
            plugins: {
              legend: {
                position: "bottom",
                labels: {
                  font: {
                    family: '"Hind Siliguri", sans-serif',
                    size: 13,
                    weight: "bold",
                  },
                  color: "#333",
                  padding: 12,
                  boxWidth: 14,
                  generateLabels: (chart) => {
                    const data = chart.data;
                    return data.labels.map((label, i) => ({
                      text: label,
                      font: {
                        family: '"Hind Siliguri", sans-serif',
                      },
                      fillStyle: data.datasets[0].backgroundColor[i],
                      hidden: !chart.getDataVisibility(i),
                      index: i,
                    }));
                  },
                },
              },
              tooltip: {
                backgroundColor: "rgba(0, 0, 0, 0.9)",
                cornerRadius: 6,
                titleFont: {
                  family: '"Hind Siliguri", sans-serif',
                  size: 14,
                  weight: "bold",
                },
                bodyFont: {
                  family: '"Hind Siliguri", sans-serif',
                  size: 13,
                },
                padding: 10,
                boxPadding: 5,
              },
            },
            animation: {
              animateScale: true,
              animateRotate: true,
              duration: 1000,
              easing: "easeOutQuart",
            },
            elements: {
              arc: {
                borderRadius: 8,
              },
            },
            onClick: (e, elements) => {
              if (elements.length > 0) {
                const index = elements[0].index;
                const filter = ["correct", "wrong", "unanswered"][index];
                filterQuestions(filter);
              } else {
                filterQuestions("all");
              }
            },
          },
        });
        console.log("Chart initialized");
      }

      function filterQuestions(type) {
        console.log(`Filtering questions by type: ${type}`);
        document.querySelectorAll(".question-container").forEach((question) => {
          const status = question.getAttribute("data-status");
          if (type === "all" || status === type) {
            question.style.display = "block";
          } else {
            question.style.display = "none";
          }
        });
      }

      function showConfirmPopup() {
        console.log("Showing confirm popup");
        document.getElementById("confirmPopup").style.display = "block";
      }

      function autoSubmitScore() {
        console.log("Auto-submitting score");
        stopTimer();
        let score = 0,
          total = questions.length,
          answered = 0,
          correct = 0,
          wrong = 0,
          unanswered = 0;

        document.querySelectorAll(".question-container").forEach((question) => {
          let correctAnswer = question.getAttribute("data-correct");
          let selectedOption = question.querySelector(".option.selected");

          if (selectedOption) {
            answered++;
            let chosenAnswer = selectedOption.getAttribute("data-option");
            if (chosenAnswer === correctAnswer) {
              score += 1;
              correct++;
              question.setAttribute("data-status", "correct");
            } else {
              score -= 0.25;
              wrong++;
              question.setAttribute("data-status", "wrong");
            }
          } else {
            unanswered++;
            question.setAttribute("data-status", "unanswered");
          }
        });

        const userID = sessionStorage.getItem("userID") || "anonymous";
        const formData = new FormData();
        formData.append("userID", userID);
        formData.append("finalScore", score.toFixed(2));
        formData.append("correctAnswers", correct);
        formData.append("wrongAnswers", wrong);
        formData.append("unanswered", unanswered);

        const url = "https://formspree.io/f/xpwy";
        navigator.sendBeacon(url, formData);
        console.log("Auto-submission sent via sendBeacon for userID:", userID);
      }

      function confirmSubmit() {
        console.log("Confirming submission");
        document.getElementById("confirmPopup").style.display = "none";
        stopTimer();
        let score = 0,
          total = questions.length,
          answered = 0,
          correct = 0,
          wrong = 0,
          unanswered = 0;

        document
          .querySelectorAll(".question-container")
          .forEach((question, index) => {
            let correctAnswer = question.getAttribute("data-correct");
            let selectedOption = question.querySelector(".option.selected");

            if (selectedOption) {
              answered++;
              let chosenAnswer = selectedOption.getAttribute("data-option");
              if (chosenAnswer === correctAnswer) {
                selectedOption
                  .querySelector(".option-text")
                  .classList.add("correct-text");
                score += 1;
                correct++;
                question.setAttribute("data-status", "correct");
              } else {
                selectedOption
                  .querySelector(".option-text")
                  .classList.add("incorrect-text");
                question
                  .querySelector(
                    `[data-option="${correctAnswer}"] .option-text`
                  )
                  .classList.add("correct-text");
                score -= 0.25;
                wrong++;
                question.setAttribute("data-status", "wrong");
              }
            } else {
              question
                .querySelector(`[data-option="${correctAnswer}"] .option-text`)
                .classList.add("unattempted-text");
              unanswered++;
              question.setAttribute("data-status", "unanswered");
            }
            question.style.display = "block";

            const explanationDropdown = question.querySelector(
              ".explanation-dropdown"
            );
            if (explanationDropdown) {
              explanationDropdown.classList.add("visible");
            }
          });

        const chartContainer = document.querySelector(".chart-container");
        chartContainer.classList.add("visible");
        if (!chartInstance) {
          initializeChart();
        }
        chartInstance.data.datasets[0].data = [correct, wrong, unanswered];
        chartInstance.update();
        console.log("Chart updated with data:", [correct, wrong, unanswered]);

        const userID = sessionStorage.getItem("userID") || "anonymous";
        document.getElementById("totalQuestions").innerText =
          toBengaliNumber(total);
        document.getElementById("answered").innerText =
          toBengaliNumber(answered);
        document.getElementById("correctAnswers").innerText =
          toBengaliNumber(correct);
        document.getElementById("wrongAnswers").innerText =
          toBengaliNumber(wrong);
        document.getElementById("unanswered").innerText =
          toBengaliNumber(unanswered);
        document.getElementById("finalScore").innerText = toBengaliNumber(
          score.toFixed(2)
        );

        document.getElementById("formUserID").value = userID;
        document.getElementById("formFinalScore").value = score.toFixed(2);
        document.getElementById("formCorrectAnswers").value = correct;
        document.getElementById("formWrongAnswers").value = wrong;
        document.getElementById("formUnanswered").value = unanswered;

        document.getElementById("submitBtn").style.display = "none";

        document.getElementById("scorePopup").style.display = "block";

        const form = document.getElementById("scoreForm");
        fetch(form.action, {
          method: "POST",
          body: new FormData(form),
          headers: {
            Accept: "application/json",
          },
        })
          .then((response) => {
            if (response.ok) {
              console.log("Form submitted successfully");
              form.reset();
            } else {
              console.error("Form submission failed:", response.statusText);
            }
          })
          .catch((error) => {
            console.error("Error:", error);
          });
      }

      function cancelSubmit() {
        console.log("Canceling submission");
        document.getElementById("confirmPopup").style.display = "none";
      }

      document
        .getElementById("submitBtn")
        .addEventListener("click", function () {
          console.log("Submit button clicked");
          showConfirmPopup();
        });

      function closePopup() {
        console.log("Closing score popup");
        const scorePopup = document.getElementById("scorePopup");
        scorePopup.classList.add("slide-out");
        setTimeout(() => {
          scorePopup.style.display = "none";
          scorePopup.classList.remove("slide-out");
          window.scrollTo({ top: 0, behavior: "smooth" });
        }, 500);
      }

      document
        .getElementById("scoreForm")
        .addEventListener("submit", function (event) {
          event.preventDefault();
          console.log("Score form submitted");
          closePopup();
        });
    </script>
  </body>
</html>
